{
  "createdAt": "2025-09-22T20:52:51.967Z",
  "updatedAt": "2025-09-22T21:42:35.135Z",
  "id": "zK6M2SirrYO8yWy4",
  "name": "Process Documents with OCR, Analytics & Google Drive using PDF Vector",
  "active": false,
  "isArchived": true,
  "nodes": [
    {
      "parameters": {
        "content": "## \ud83d\udcca Real-Time Analytics\n\nDocument processing metrics:\n\u2022 **Tracks** all workflows in database\n\u2022 **Calculates** KPIs every 30 minutes\n\u2022 **Monitors** success/failure rates\n\u2022 **Analyzes** trends & patterns\n\u2022 **Updates** dashboards automatically",
        "height": 244,
        "width": 350,
        "color": 5
      },
      "id": "overview-note",
      "name": "Analytics Overview",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        368,
        240
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "content": "## \ud83d\udcc8 Key Metrics\n\n**Tracking:**\n\u2022 Documents/hour\n\u2022 Processing time\n\u2022 Error rates\n\u2022 API usage\n\u2022 Cost analysis\n\n\ud83d\udca1 30-day rolling window",
        "height": 256,
        "width": 260
      },
      "id": "metrics-note",
      "name": "Metrics Tracked",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        768,
        752
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "content": "## \ud83d\udcca Visualizations\n\n**Outputs to:**\n\u2022 Google Sheets\n\u2022 Tableau\n\u2022 Power BI\n\u2022 Slack alerts\n\n\u2728 Real-time updates!",
        "height": 246,
        "width": 250,
        "color": 6
      },
      "id": "output-note",
      "name": "Dashboard Output",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1072,
        752
      ],
      "typeVersion": 1
    },
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "position": [
        576,
        496
      ],
      "typeVersion": 1,
      "notes": "Start batch processing"
    },
    {
      "parameters": {
        "resource": "fileFolder",
        "queryString": "*",
        "returnAll": true,
        "filter": {
          "folderId": {
            "__rl": true,
            "value": "13cawol0keib58mS--h23xWgid31el-Ub",
            "mode": "id"
          }
        },
        "options": {
          "fields": [
            "name",
            "id",
            "mimeType"
          ]
        }
      },
      "id": "list-documents",
      "name": "List Documents",
      "type": "n8n-nodes-base.googleDrive",
      "position": [
        768,
        496
      ],
      "typeVersion": 3,
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "41A8x3MtmKUsugVg",
          "name": "JVX OAuth2"
        }
      },
      "notes": "Replace FOLDER_ID_HERE with your Google Drive folder ID"
    },
    {
      "parameters": {
        "jsCode": "// Validate and categorize documents\nconst files = $input.all().map(item => item.json);\nconst processingQueue = {\n  valid: [],\n  invalid: [],\n  stats: {\n    totalFiles: files.length,\n    pdfCount: 0,\n    wordCount: 0,\n    imageCount: 0,\n    otherCount: 0,\n    totalSizeMB: 0\n  }\n};\n\n// Define supported formats\nconst supportedFormats = {\n  pdf: ['application/pdf'],\n  word: [\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/msword'\n  ],\n  image: ['image/jpeg', 'image/png', 'image/gif']\n};\n\nfiles.forEach(file => {\n  const mimeType = file.mimeType;\n  const sizeMB = (parseInt(file.size) || 0) / (1024 * 1024);\n  \n  // Check if supported\n  let fileType = 'other';\n  let isValid = false;\n  \n  if (supportedFormats.pdf.includes(mimeType)) {\n    fileType = 'pdf';\n    isValid = true;\n    processingQueue.stats.pdfCount++;\n  } else if (supportedFormats.word.includes(mimeType)) {\n    fileType = 'word';\n    isValid = true;\n    processingQueue.stats.wordCount++;\n  } else if (supportedFormats.image.includes(mimeType)) {\n    fileType = 'image';\n    isValid = true;\n    processingQueue.stats.imageCount++;\n  } else {\n    processingQueue.stats.otherCount++;\n  }\n  \n  // Check file size (max 50MB)\n  if (sizeMB > 50) {\n    isValid = false;\n  }\n  \n  const fileInfo = {\n    ...file,\n    fileType,\n    sizeMB: Math.round(sizeMB * 100) / 100,\n    processingPriority: sizeMB < 5 ? 'high' : sizeMB < 20 ? 'medium' : 'low',\n    estimatedCredits: fileType === 'pdf' ? Math.ceil(sizeMB * 2) : 1\n  };\n  \n  if (isValid) {\n    processingQueue.valid.push(fileInfo);\n  } else {\n    processingQueue.invalid.push({\n      ...fileInfo,\n      reason: sizeMB > 50 ? 'File too large' : 'Unsupported format'\n    });\n  }\n  \n  processingQueue.stats.totalSizeMB += sizeMB;\n});\n\n// Sort by priority\nprocessingQueue.valid.sort((a, b) => {\n  const priority = { high: 1, medium: 2, low: 3 };\n  return priority[a.processingPriority] - priority[b.processingPriority];\n});\n\nreturn [{\n  json: processingQueue\n}];"
      },
      "id": "validate-files",
      "name": "Validate & Queue Files",
      "type": "n8n-nodes-base.code",
      "position": [
        976,
        496
      ],
      "typeVersion": 2,
      "notes": "Validate and prioritize files"
    },
    {
      "parameters": {
        "batchSize": 5,
        "options": {}
      },
      "id": "batch-processor",
      "name": "Process in Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "position": [
        1168,
        496
      ],
      "typeVersion": 3,
      "notes": "Process 5 files at a time"
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "split-files",
      "name": "Split Out Files",
      "type": "n8n-nodes-base.set",
      "position": [
        1376,
        496
      ],
      "typeVersion": 3,
      "notes": "Prepare individual files"
    },
    {
      "parameters": {
        "fieldToSplitOut": "processingBatch.valid",
        "options": {}
      },
      "id": "split-items",
      "name": "Split Items",
      "type": "n8n-nodes-base.splitOut",
      "position": [
        1568,
        496
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "resource": "document",
        "url": "="
      },
      "id": "pdfvector-process",
      "name": "PDF Vector - Process Document/Image",
      "type": "n8n-nodes-pdfvector.pdfVector",
      "position": [
        1760,
        320
      ],
      "typeVersion": 1,
      "credentials": {
        "pdfVectorApi": {
          "id": "tFKVtvwCKHdENOzH",
          "name": "jvx PDF Vector account"
        }
      },
      "continueOnFail": true,
      "notes": "Process document or image"
    },
    {
      "parameters": {
        "jsCode": "// Track processing results\nconst result = $input.first().json;\nconst originalFile = $node['Split Items'].json;\nconst startTime = new Date($node['Split Items'].context.executionTime);\nconst endTime = new Date();\nconst processingTime = (endTime - startTime) / 1000;\n\nconst processedFile = {\n  // Original file info\n  fileName: originalFile.name,\n  fileType: originalFile.fileType,\n  sizeMB: originalFile.sizeMB,\n  \n  // Processing results\n  success: !result.error,\n  processingTime: Math.round(processingTime * 100) / 100,\n  creditsUsed: result.creditsUsed || originalFile.estimatedCredits,\n  \n  // Content info\n  contentLength: result.content?.length || 0,\n  wordCount: result.content?.split(' ').length || 0,\n  \n  // Error tracking\n  error: result.error ? {\n    message: result.error.message || 'Unknown error',\n    code: result.error.code\n  } : null,\n  \n  // Timestamps\n  processedAt: new Date().toISOString()\n};\n\n// Quality checks\nif (processedFile.success) {\n  processedFile.qualityChecks = {\n    hasContent: processedFile.contentLength > 100,\n    reasonableLength: processedFile.wordCount > 10 && processedFile.wordCount < 100000,\n    properEncoding: !result.content?.includes('\ufffd'),\n    creditsEfficiency: processedFile.creditsUsed / processedFile.sizeMB < 5\n  };\n  \n  // Overall quality score\n  const checks = Object.values(processedFile.qualityChecks);\n  processedFile.qualityScore = (checks.filter(c => c).length / checks.length) * 100;\n}\n\nreturn [{ json: processedFile }];"
      },
      "id": "track-results",
      "name": "Track Processing Results",
      "type": "n8n-nodes-base.code",
      "position": [
        1968,
        496
      ],
      "typeVersion": 2,
      "notes": "Analyze results"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "collect-batch",
      "name": "Collect Batch Results",
      "type": "n8n-nodes-base.aggregate",
      "position": [
        2176,
        496
      ],
      "typeVersion": 1,
      "notes": "Aggregate batch results"
    },
    {
      "parameters": {
        "jsCode": "// Generate comprehensive analytics report\nconst allResults = $input.all().map(item => item.json);\nconst initialStats = $node['Validate & Queue Files'].json.stats;\n\n// Calculate processing analytics\nconst analytics = {\n  overview: {\n    totalFilesFound: initialStats.totalFiles,\n    filesProcessed: allResults.length,\n    successfulProcessing: allResults.filter(r => r.success).length,\n    failedProcessing: allResults.filter(r => !r.success).length,\n    successRate: 0,\n    totalProcessingTime: 0,\n    totalCreditsUsed: 0,\n    averageQualityScore: 0\n  },\n  \n  byFileType: {\n    pdf: { processed: 0, successful: 0, failed: 0, avgTime: 0, creditsUsed: 0 },\n    word: { processed: 0, successful: 0, failed: 0, avgTime: 0, creditsUsed: 0 },\n    image: { processed: 0, successful: 0, failed: 0, avgTime: 0, creditsUsed: 0 }\n  },\n  \n  errors: {},\n  \n  performance: {\n    fastestFile: null,\n    slowestFile: null,\n    mostEfficientCredit: null,\n    leastEfficientCredit: null\n  },\n  \n  quality: {\n    highQuality: [],\n    lowQuality: [],\n    averageWordCount: 0\n  }\n};\n\n// Process results\nlet totalQualityScore = 0;\nlet qualityCount = 0;\n\nallResults.forEach(result => {\n  // Update overview\n  analytics.overview.totalProcessingTime += result.processingTime || 0;\n  analytics.overview.totalCreditsUsed += result.creditsUsed || 0;\n  \n  // Update by file type\n  const type = result.fileType;\n  if (analytics.byFileType[type]) {\n    analytics.byFileType[type].processed++;\n    if (result.success) {\n      analytics.byFileType[type].successful++;\n    } else {\n      analytics.byFileType[type].failed++;\n    }\n    analytics.byFileType[type].avgTime += result.processingTime || 0;\n    analytics.byFileType[type].creditsUsed += result.creditsUsed || 0;\n  }\n  \n  // Track errors\n  if (result.error) {\n    const errorType = result.error.message || 'Unknown';\n    analytics.errors[errorType] = (analytics.errors[errorType] || 0) + 1;\n  }\n  \n  // Track performance\n  if (!analytics.performance.fastestFile || result.processingTime < analytics.performance.fastestFile.time) {\n    analytics.performance.fastestFile = {\n      name: result.fileName,\n      time: result.processingTime\n    };\n  }\n  if (!analytics.performance.slowestFile || result.processingTime > analytics.performance.slowestFile.time) {\n    analytics.performance.slowestFile = {\n      name: result.fileName,\n      time: result.processingTime\n    };\n  }\n  \n  // Track quality\n  if (result.qualityScore !== undefined) {\n    totalQualityScore += result.qualityScore;\n    qualityCount++;\n    \n    if (result.qualityScore >= 75) {\n      analytics.quality.highQuality.push(result.fileName);\n    } else if (result.qualityScore < 50) {\n      analytics.quality.lowQuality.push(result.fileName);\n    }\n  }\n  \n  analytics.quality.averageWordCount += result.wordCount || 0;\n});\n\n// Calculate averages\nanalytics.overview.successRate = Math.round((analytics.overview.successfulProcessing / analytics.overview.filesProcessed) * 100);\nanalytics.overview.averageQualityScore = qualityCount > 0 ? Math.round(totalQualityScore / qualityCount) : 0;\nanalytics.quality.averageWordCount = Math.round(analytics.quality.averageWordCount / allResults.length);\n\n// Calculate file type averages\nObject.keys(analytics.byFileType).forEach(type => {\n  const typeData = analytics.byFileType[type];\n  if (typeData.processed > 0) {\n    typeData.avgTime = Math.round((typeData.avgTime / typeData.processed) * 100) / 100;\n    typeData.successRate = Math.round((typeData.successful / typeData.processed) * 100);\n  }\n});\n\n// Generate report\nlet report = `# Batch Processing Analytics Report\\n\\n`;\nreport += `**Generated:** ${new Date().toLocaleString()}\\n\\n`;\n\nreport += `## Overview\\n`;\nreport += `- **Files Processed:** ${analytics.overview.filesProcessed} of ${analytics.overview.totalFilesFound}\\n`;\nreport += `- **Success Rate:** ${analytics.overview.successRate}%\\n`;\nreport += `- **Total Processing Time:** ${Math.round(analytics.overview.totalProcessingTime)}s\\n`;\nreport += `- **Credits Used:** ${analytics.overview.totalCreditsUsed}\\n`;\nreport += `- **Average Quality Score:** ${analytics.overview.averageQualityScore}%\\n\\n`;\n\nreport += `## Performance by File Type\\n`;\nObject.entries(analytics.byFileType).forEach(([type, data]) => {\n  if (data.processed > 0) {\n    report += `### ${type.toUpperCase()}\\n`;\n    report += `- Processed: ${data.processed}\\n`;\n    report += `- Success Rate: ${data.successRate}%\\n`;\n    report += `- Avg Time: ${data.avgTime}s\\n`;\n    report += `- Credits: ${data.creditsUsed}\\n\\n`;\n  }\n});\n\nif (Object.keys(analytics.errors).length > 0) {\n  report += `## Errors Encountered\\n`;\n  Object.entries(analytics.errors).forEach(([error, count]) => {\n    report += `- ${error}: ${count} occurrences\\n`;\n  });\n  report += `\\n`;\n}\n\nreport += `## Recommendations\\n`;\nif (analytics.overview.successRate < 90) {\n  report += `- Success rate is below 90%. Review error logs for common issues.\\n`;\n}\nif (analytics.overview.averageQualityScore < 70) {\n  report += `- Quality scores are low. Consider using 'always' LLM mode for better results.\\n`;\n}\nif (analytics.quality.lowQuality.length > 0) {\n  report += `- ${analytics.quality.lowQuality.length} files had low quality scores. Manual review recommended.\\n`;\n}\n\nreturn [{\n  json: {\n    analytics,\n    report,\n    processedFiles: allResults,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "generate-analytics",
      "name": "Generate Analytics Report",
      "type": "n8n-nodes-base.code",
      "position": [
        2368,
        496
      ],
      "typeVersion": 2,
      "notes": "Create analytics dashboard"
    },
    {
      "parameters": {
        "url": "https://www.googleapis.com/drive/v3/files",
        "authentication": "genericCredentialType",
        "genericAuthType": "oAuth2Api",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "q",
              "value": "13cawol0keib58mS--h23xWgid31el-Ub"
            },
            {
              "name": "fields",
              "value": "files(id,name,mimeType)"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        880,
        224
      ],
      "id": "5511b863-6ea8-4f8b-be17-33c8a7b772f8",
      "name": "HTTP Request",
      "credentials": {
        "oAuth2Api": {
          "id": "dgzbzxBeRI9Di7f8",
          "name": "jvx oauth2 gdrive"
        }
      }
    }
  ],
  "connections": {
    "Split Items": {
      "main": [
        [
          {
            "node": "PDF Vector - Process Document/Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List Documents": {
      "main": [
        [
          {
            "node": "Validate & Queue Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "List Documents",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out Files": {
      "main": [
        [
          {
            "node": "Split Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process in Batches": {
      "main": [
        [
          {
            "node": "Split Out Files",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Analytics Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Batch Results": {
      "main": [
        [
          {
            "node": "Generate Analytics Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Queue Files": {
      "main": [
        [
          {
            "node": "Process in Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Track Processing Results": {
      "main": [
        [
          {
            "node": "Collect Batch Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PDF Vector - Process Document/Image": {
      "main": [
        [
          {
            "node": "Track Processing Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {},
  "staticData": null,
  "meta": {
    "templateId": "8505",
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "6aa799d0-5d5f-4633-8922-5358d61ce33c",
  "triggerCount": 0,
  "tags": [],
  "shared": [
    {
      "createdAt": "2025-09-22T20:52:51.967Z",
      "updatedAt": "2025-09-22T20:52:51.967Z",
      "role": "workflow:owner",
      "workflowId": "zK6M2SirrYO8yWy4",
      "projectId": "QEiebo2x6YENAnrq",
      "project": {
        "createdAt": "2025-03-12T12:15:21.659Z",
        "updatedAt": "2025-03-15T14:25:50.674Z",
        "id": "QEiebo2x6YENAnrq",
        "name": "Joel Quinn Ebb-Wrightten <n8n.admin@virtualxperiencellc.com>",
        "type": "personal",
        "icon": null,
        "description": null
      }
    }
  ]
}